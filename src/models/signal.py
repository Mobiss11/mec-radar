from datetime import datetime
from decimal import Decimal

from sqlalchemy import Boolean, DateTime, ForeignKey, Index, Integer, JSON, Numeric, String, func, text
from sqlalchemy.orm import Mapped, mapped_column

from src.models.base import Base


class Signal(Base):
    """Trading signal generated by the scoring engine."""

    __tablename__ = "signals"

    id: Mapped[int] = mapped_column(primary_key=True)
    token_id: Mapped[int] = mapped_column(ForeignKey("tokens.id"))
    token_address: Mapped[str] = mapped_column(String(64))
    score: Mapped[int] = mapped_column(Integer)
    reasons: Mapped[dict | None] = mapped_column(JSON)
    token_price_at_signal: Mapped[Decimal | None] = mapped_column(Numeric)
    token_mcap_at_signal: Mapped[Decimal | None] = mapped_column(Numeric)
    liquidity_at_signal: Mapped[Decimal | None] = mapped_column(Numeric)
    status: Mapped[str] = mapped_column(String(20), default="pending")
    created_at: Mapped[datetime] = mapped_column(DateTime, server_default=func.now())
    updated_at: Mapped[datetime] = mapped_column(
        DateTime, server_default=func.now(), onupdate=func.now()
    )

    # Outcome tracking â€” updated by upsert_token_outcome
    peak_roi_pct: Mapped[Decimal | None] = mapped_column(Numeric)
    peak_multiplier_after: Mapped[Decimal | None] = mapped_column(Numeric)
    is_rug_after: Mapped[bool | None] = mapped_column(Boolean)
    outcome_updated_at: Mapped[datetime | None] = mapped_column(DateTime)

    __table_args__ = (
        Index("idx_signals_status_created", "status", "created_at"),
        Index("idx_signals_status_updated", "status", "updated_at"),
        Index("idx_signals_token", "token_id"),
        Index("idx_signals_address", "token_address"),
        # Partial unique: one active signal per (token_id, status) for dedup
        Index(
            "uq_signals_token_status_active",
            "token_id", "status",
            unique=True,
            postgresql_where=text("status IN ('strong_buy', 'buy', 'watch')"),
        ),
    )
